# 從 PRD 生成任務清單

## 目標

引導 AI 助手根據現有的產品需求文件（PRD）創建詳細的、逐步的 Markdown 格式任務清單。該任務清單應指導開發人員完成實作。

## 工作流程脈絡

### 整體開發流程

本指令是 claude-code-config 三步驟開發流程中的**第二步：實作規劃**。完整流程如下：

1. **【選用】需求研究 (`/research`)**：深入調查技術問題、探索解決方案、產出研究文件
2. **需求澄清 (`/create-prd`)**：透過問答釐清需求、產出 PRD 文件
3. **【當前】實作規劃 (`/create-impl-plan`)**：分析 PRD 和程式碼庫、產出任務清單和驗收測試
4. **任務執行 (`/process-task-list`)**：逐一實作任務、執行驗收測試

### 當前階段的輸入與輸出

**輸入來源**：
- PRD 文件（包含功能需求和高層次技術方向）
- 【選用】Research 文件（如果 PRD 中有引用）
- 現有程式碼庫（用於了解架構和慣例）

**輸出目標**：
- Implementation.md（任務清單和實作要點）
- acceptance.feature（Gherkin 格式驗收測試）
- 目標讀者：**開發者（初級到中級）**
- 閱讀目的：理解實作任務、技術細節、驗收標準

### 當前階段的職責範圍

**應該包含**：
- 詳細的實作任務清單（5-7 個主要任務）
- 每個任務的具體實作要點（技術層面的指導）
- 需要建立或修改的檔案清單
- 詳細的 Gherkin 驗收測試場景
- **實作參考資訊章節**：承接 research 和 PRD 的技術細節

**不應該包含**：
- 商業背景和使用者價值的重複說明（這些在 PRD 中）
- 過度詳細的逐行程式碼（這是執行時的產物）

### 與其他階段的關係

**承接 PRD 和 research**：
- PRD 提供高層次需求和技術方向，本階段將其展開成具體任務
- PRD 的高階驗收標準會被轉化成詳細的 Gherkin 場景
- **關鍵責任**：將 research 文件和 PRD 中的技術細節（程式碼範例、架構決策、技術分析）萃取並保留在「實作參考資訊」章節
- 這個階段是技術細節的「承接點」，確保前期的技術討論不會遺失

**為下游階段準備**：
- Implementation.md 會被 `/process-task-list` 讀取，用來執行任務
- 開發者會在執行任務時參考「實作參考資訊」章節
- Acceptance.feature 會在驗收測試階段被執行

## 輸出

### 主要任務清單

- **格式：** Markdown (`.md`)
- **位置：** `/docs/specs/[prd-slug-name]`
- **檔案名稱：** `implementation.md`

### 驗收條件檔案

- **格式：** Gherkin (`.feature`)
- **位置：** `/docs/specs/[prd-slug-name]`
- **檔案名稱：** `acceptance.feature`

## 流程

1.  **接收 PRD 參考：** 用戶指向特定的 PRD 檔案
2.  **分析 PRD 和萃取實作資訊：** AI 讀取並分析指定 PRD 的功能需求、用戶故事和其他部分。如果 PRD 中引用了研究文件，也一併讀取相關研究以獲得更深入的背景資訊。

   **實作資訊萃取策略：**
   - 重點識別實作相關的技術內容，排除純理論討論
   - 保持程式碼範例和實作模式的概念正確性
   - 確保技術決策包含足夠的背景脈絡
   - 維持資訊的簡潔性，避免與任務清單重複

   **特別提取以下技術資訊：**
   - 程式碼範例和實作示範
   - 技術選型的詳細分析和理由
   - 架構決策和設計模式
   - 具體的 API 設計或檔案結構
   - 已驗證的解決方案和最佳實踐
   - 技術限制和考量事項
3.  **評估現狀：** 檢視現有程式碼庫，了解現有的基礎設施、架構模式和慣例。同時，識別任何已存在且可能與 PRD 需求相關的元件或功能。然後，識別可以利用或需要修改的現有相關檔案、元件和工具。
4.  **生成任務與任務說明：** 基於 PRD 分析和現狀評估，創建檔案並生成實作功能所需的主要任務。根據判斷決定使用多少個任務，通常約為 5-7 個。為每個任務生成詳細的任務說明（以條列式呈現），用於與開發者溝通開發範圍和實作細節，確保涵蓋 PRD 暗示的所有實作要點。同時為每個任務生成「完成檢查」，提供 1-5 條簡要的檢查要點，說明如何驗證該任務已完成（詳見「完成檢查生成指引」章節）。

   **測試整合原則：**
   - **不建立獨立的測試任務**：測試應該整合在實作任務中，作為實作的一部分
   - **完成檢查包含驗證**：每個任務的「完成檢查」應包含適當的驗證方式（如單元測試執行、MCP 工具檢查、指令執行、手動驗證等）
   - **及早驗證、及早修正**：實作完成後立即執行完成檢查，在進入下一個任務前發現並修正問題
   - **驗收測試獨立**：功能層級的完整驗收測試仍保持為獨立的「執行驗收測試」任務
5.  **生成驗收條件：** 基於 PRD 中的 Acceptance Criteria 部分，創建 Gherkin 格式的驗收測試場景。每個驗收條件應轉換為具體的 Feature、Scenario 和 Given/When/Then 步驟。這些步驟將由 AI 通過指令或 MCP 瀏覽器操作直接執行，而非傳統的 Cucumber glue code。
6.  **生成最終輸出：** 將任務、任務說明、相關檔案和備註結合到最終的 Markdown 結構中。在任務清單末尾添加驗收測試任務和更新專案文件任務。接著將提取的實作參考資訊組織成三個子章節，放置在文件最後：
   - 來自研究文件的技術洞察（如無 research 文件則留空或省略）
   - 來自 PRD 的實作細節
   - 關鍵技術決策總結
7.  **儲存檔案：**
    - 將任務清單儲存為 `implementation.md`（位置：`/docs/specs/[prd-slug-name]/`）
    - 將 Gherkin 驗收條件儲存為 `acceptance.feature`（位置：`/docs/specs/[prd-slug-name]/`）

## 輸出格式

### 任務清單 (implementation.md)

生成的任務清單**必須**遵循以下結構：

<example>
```markdown
# 實作計畫

## PRD 參考

**PRD 文件路徑：** `[PRD 檔案的相對路徑]`
**相關研究文件：** `[如果 PRD 引用了研究文件，列出研究文件路徑，如無則省略此行]`

## 任務概要

- [ ] 任務標題 1
- [ ] 任務標題 2
- [ ] 任務標題 3
- [ ] 任務標題 4
- [ ] 執行驗收測試
- [ ] 更新專案文件

## 任務細節

### 任務標題 1

**實作要點**
- 實作要點描述
- 實作要點描述
- 實作要點描述

**相關檔案**
- `path/to/file1.ts` - 簡要說明此檔案為何相關
- `path/to/file2.test.ts` - 測試檔案

**完成檢查**
- 檢查要點描述（1-5 條簡要說明）

**實作備註**
<!-- 執行過程中填寫重要的技術決策、障礙和需要傳遞的上下文 -->

---

### 執行驗收測試

**實作要點**
- 使用 AI 讀取 acceptance.feature 檔案
- 透過指令或 MCP 瀏覽器操作執行每個場景
- 驗證所有場景通過並記錄結果
- 如發現問題，記錄詳細的錯誤資訊和重現步驟

**相關檔案**
- `acceptance.feature` - Gherkin 格式的驗收測試場景
- `acceptance-report.md` - 詳細的驗收測試執行報告（執行時生成）

**實作備註**
<!-- 執行過程中填寫 -->

---

### 更新專案文件

**實作要點**
- 審查 README.md，根據新功能更新使用說明和功能清單
- 審查 CLAUDE.md，更新專案架構和技術考量說明
- 審查其他專案層級文件（如 API 文件、部署指南、貢獻指南等）
- 注意文件長度控制：適時摘要舊內容，抽象化技術細節
- 確保所有程式碼範例和指令都是最新且可執行的
- **注意**：不需要更新 docs/research 和 docs/specs 目錄中的歷史文件

**相關檔案**
- `README.md` - 專案主要說明文件
- `CLAUDE.md` - AI 助手的專案指引文件
- 其他專案層級的 `.md` 文件（根據實際需求識別）

**實作備註**
<!-- 執行過程中填寫 -->

---

## 實作參考資訊

### 來自研究文件的技術洞察
> **文件路徑：** `[研究文件路徑，如無則省略此章節]`

- [提取的技術洞察和實作方法]
- [程式碼範例和實作模式]
- [已驗證的解決方案]

### 來自 PRD 的實作細節
> **文件路徑：** 參考上方 PRD 參考章節

- [技術架構決策和理由]
- [具體的 API 設計或檔案結構]
- [PRD 中提到的實作範例]
- [技術限制和考量事項]

### 關鍵技術決策
- [總結關鍵技術選擇和其依據]
- [重要的實作細節和注意事項]
```
</example>

### 驗收條件檔案 (acceptance.feature)

Gherkin 格式的驗收條件**必須**遵循以下結構：

<example>
```gherkin
# language: zh-TW
功能: [功能名稱]
  作為 [使用者角色]
  我想要 [功能目標]
  以便 [商業價值]

  背景:
    假設 [系統初始狀態]
    並且 [額外的前置條件]

  場景: [場景名稱 - 對應 PRD 中的一個驗收條件]
    假設 [前置條件]
    當 [使用者執行的動作]
    那麼 [預期結果]
    並且 [額外的驗證]

  場景: [另一個場景名稱]
    假設 [前置條件]
    當 [使用者執行的動作]
    那麼 [預期結果]

  場景大綱: [參數化的場景]
    假設 用戶輸入 "<input>"
    當 系統處理輸入
    那麼 應該返回 "<output>"

    例子:
      | input | output |
      | 值1   | 結果1  |
      | 值2   | 結果2  |
```
</example>

### 驗收測試執行說明

驗收測試由 AI 直接執行：讀取 acceptance.feature 場景 → 轉換為指令或瀏覽器操作 → 執行並驗證 → 報告結果（包含預期之外的情況或警告）

### 視角區分：完成檢查 vs. 驗收測試

在撰寫驗收測試時，必須清楚區分「完成檢查」與「驗收測試」的視角差異：

#### 完成檢查（開發者視角）
- **目的**：驗證技術實作的正確性
- **執行時機**：每個任務完成後立即執行
- **檢查方式範例**：
  - 執行單元測試或整合測試
  - 使用 supabase mcp 直接查詢資料庫欄位
  - 使用 curl 測試 API 端點回應
  - 檢查日誌檔案或建置輸出
  - 驗證檔案結構或設定檔內容

#### 驗收測試（使用者視角）
- **目的**：驗證功能符合使用者需求和預期體驗
- **執行時機**：所有任務完成後的系統性驗證
- **檢查方式範例**：
  - 使用 playwright mcp 開啟瀏覽器，模擬使用者操作 UI
  - 驗證使用者可見的介面元素（按鈕、表單、訊息等）
  - 測試完整的使用者流程（註冊 → 登入 → 使用功能）
  - 確認使用者可感知的行為（頁面跳轉、錯誤提示、成功訊息等）

#### 視角區分範例

假設功能：「新增用戶個人資料欄位」

**❌ 錯誤範例（驗收測試混入開發者視角）**：
```gherkin
場景: 新增用戶個人資料欄位
  假設 系統已啟動
  當 使用 supabase mcp 查詢 users 表格
  那麼 應該看到 bio 和 avatar_url 欄位存在
```

**✅ 正確範例（完成檢查用開發者視角，驗收測試用使用者視角）**：

*完成檢查（implementation.md 中）*：
- 使用 supabase mcp 查詢 users 表格，確認 bio 和 avatar_url 欄位存在

*驗收測試（acceptance.feature 中）*：
```gherkin
場景: 用戶可以編輯個人資料
  假設 用戶已登入系統
  當 使用 playwright mcp 開啟個人資料頁面
  並且 在「自我介紹」欄位輸入文字
  並且 上傳大頭貼圖片
  並且 點擊「儲存」按鈕
  那麼 應該看到「個人資料已更新」的成功訊息
  並且 重新整理頁面後，自我介紹和大頭貼仍然正確顯示
```

#### 撰寫驗收測試的關鍵原則

1. **以使用者旅程為主**：描述使用者如何與系統互動，而非技術實作細節
2. **優先使用 UI 驗證**：盡可能透過 playwright mcp 驗證使用者可見的介面
3. **避免直接存取底層**：不直接查詢資料庫、不檢查 API 回應格式（除非是 API 產品）
4. **關注使用者價值**：驗證使用者能否達成目標，而非技術元件是否正確

## 完成檢查生成指引

為每個任務生成「完成檢查」章節，提供 1-5 條簡要的檢查要點，說明如何快速確認該任務已完成。這與最後的「執行驗收測試」任務不同：

- **完成檢查**：任務層級的快速檢查（完成單一任務後立即確認）
- **執行驗收測試**：功能層級的完整驗收（所有任務完成後的系統性驗證）

### 生成原則

1. **簡潔性**：1-5 條檢查要點，通常 1-2 條最理想
2. **可執行性**：提供具體可執行的檢查方法
3. **相關性**：聚焦於該任務的產出
4. **多樣性**：根據任務特性選擇適當的檢查方式

### 不同任務類型的完成檢查指引

**1. 實作新功能或修改邏輯的任務**
- 優先考慮單元測試
- 範例：「執行 `npm test` 確認新增/修改的測試通過」

**2. API 開發任務**
- 建議使用 curl 或其他 HTTP 測試工具
- 範例：「使用 `curl -X POST http://localhost:3000/api/users` 測試端點回應正確」

**3. 資料庫相關任務**
- 建議使用 supabase mcp（如果專案使用 Supabase）或資料庫查詢工具
- 範例：
  - 「使用 supabase mcp 查詢 users 表格，確認新增欄位存在」
  - 「使用 supabase mcp 插入測試資料，確認 unique constraint 正常運作」

**4. 前端 UI 任務**
- 建議使用 playwright mcp（如果可用）或手動測試
- 範例：「使用 playwright mcp 開啟 /settings 頁面，確認主題切換按鈕顯示正確」

**5. CLI 工具或腳本任務**
- 建議執行指令驗證
- 範例：「執行 `node scripts/migrate.js` 確認腳本正常運作無錯誤」

**6. 檔案結構重構任務**
- 建議檢查檔案系統
- 範例：「確認所有檔案已移動到 `src/ui/` 目錄且舊目錄已清空」

**7. 建置相關任務**
- 建議執行建置指令
- 範例：「執行 `npm run build` 確認建置成功無 TypeScript 錯誤」

**8. 環境設定任務**
- 建議驗證環境變數或設定檔
- 範例：「確認 `.env` 檔案包含所有必要的環境變數且格式正確」

**9. 複雜任務（難以單一驗證）**
- 提供 2-5 個檢查要點
- 涵蓋主要產出的檢查方式
- 範例：
  - 「執行單元測試確認核心邏輯通過」
  - 「使用 curl 測試 API 端點回應正確」
  - 「檢查日誌檔案確認無錯誤訊息」

### 排除規則

以下任務類型**不應**包含「完成檢查」章節：

1. **執行驗收測試**：任務本身就是驗收測試
2. **更新專案文件**：文件更新的驗證較為主觀，通常透過 PR review 進行

## 任務格式說明

### 雙層結構設計

implementation.md 採用「任務概要 + 任務細節」的雙層結構：

- **任務概要**：簡潔的 checkbox 列表，用於快速瀏覽和 TodoWrite 同步
- **任務細節**：每個任務的完整章節，包含實作要點、相關檔案、完成檢查、實作備註
- **關鍵原則**：標題必須完全一致，不使用編號

### 任務細節結構

每個任務包含四個固定子區塊：

- **實作要點**：具體的實作步驟（條列式）
- **相關檔案**：該任務需要修改的檔案清單（每個任務獨立，不使用全域區塊）
- **完成檢查**：1-5 條簡要的檢查要點，說明如何確認該任務已完成
- **實作備註**：執行時填寫的上下文記錄（HTML 註解格式）

**注意**：「執行驗收測試」和「更新專案文件」兩個固定任務不包含「完成檢查」章節。

**任務標題原則**：
- 使用描述性標題，避免編號（如「建立檔案掃描和路由生成工具」而非「任務 1」）
- 概要和細節的標題必須完全一致

**實作備註填寫指引**：
- **必須記錄**：與原始計畫的重大偏離、關鍵技術決策、技術障礙、需要後續任務注意的依賴
- **不需記錄**：照預期完成的實作（可標註「照預期開發」或留空）、過於細節的程式碼變更、可從其他文件取得的資訊
- **記錄原則**：只記錄下一個任務或對話框需要知道、但無法從現有文件得到的上下文

### 必要任務

每個 implementation.md 必須包含以下兩個任務：

1. **執行驗收測試**：在所有功能任務完成後執行
2. **更新專案文件**：在驗收測試後更新 README.md、CLAUDE.md 等專案層級文件（不包含 docs/research 和 docs/specs 歷史文件）

## 目標受眾

假設任務清單的主要讀者是**初級開發人員**，他們將在了解現有程式碼庫背景的情況下實作功能。

